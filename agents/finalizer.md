**FINALIZER AGENT SPECIFICATION**

Creates pull requests and manages final integration after successful review.

**ROLE:** Complete the development cycle by creating PRs and ensuring clean integration

**IMPORTS:**
```
- ../lib/state-manager.md           # For state persistence
- ../lib/progress-tracker.md        # For progress updates
- ../protocols/merge-conflict.md    # For conflict resolution
- ../protocols/safe-cleanup.md      # For resource cleanup
```

**INPUT CONTEXT:**
```
{
  task_id: number,
  task_spec: {
    title: string,
    description: string,
    details: string
  },
  worktree_path: string,              # e.g., ".worktrees/task-8"
  branch_name: string,                # e.g., "feature/task-8"
  review_results: {
    requirements_coverage: number,
    test_coverage: number,
    quality_score: number
  },
  config: {
    pr_template: string,
    auto_merge_enabled: boolean,
    cleanup_strategy: string
  },
  session_id: string
}
```

**WORKFLOW:**

**STEP 1: Pre-flight Checks**
```
1. Navigate to worktree:
   - cd {worktree_path}
   
2. Verify branch status:
   - Check all changes committed
   - Ensure branch is up to date with base
   - Identify any uncommitted files
   
3. Update status:
   - Report: "Finalizing Task {task_id}"
   - Progress: "Pre-flight checks (10%)"
```

**STEP 2: Prepare Final Commit**
```
1. Check for uncommitted changes:
   IF has_uncommitted_changes():
       # Stage all changes
       git add -A
       
       # Create final commit
       commit_message = generate_commit_message(task_spec, "final")
       git commit -m "{commit_message}"
   END
   
2. Squash commits if needed:
   IF config.squash_commits:
       # Interactive rebase to squash
       squash_commits_safely()
   END
   
Progress: "Changes committed (20%)"
```

**STEP 3: Sync with Base Branch**
```
1. Fetch latest changes:
   - git fetch origin
   
2. Merge or rebase with base:
   IF config.use_rebase:
       git rebase origin/main
   ELSE:
       git merge origin/main
   END
   
3. Handle conflicts if any:
   IF has_conflicts():
       resolved = execute_merge_conflict_resolution()
       IF not resolved:
           RETURN: {
               status: "blocked",
               reason: "merge_conflicts",
               requires: "manual_intervention"
           }
       END
   END
   
Progress: "Synced with base (40%)"
```

**STEP 4: Push to Remote**
```
1. Push branch to origin:
   git push -u origin {branch_name}
   
2. Verify push successful:
   - Check remote branch exists
   - Confirm all commits pushed
   
Progress: "Pushed to remote (50%)"
```

**STEP 5: Create Pull Request**
```
1. Generate PR content:
   pr_title = generate_pr_title(task_spec)
   pr_body = generate_pr_body({
       task_spec: task_spec,
       implementation_summary: analyze_changes(),
       test_results: review_results,
       checklist: config.pr_checklist
   })
   
2. Create PR using gh CLI:
   pr_result = gh pr create \
       --title "{pr_title}" \
       --body "{pr_body}" \
       --base main \
       --head {branch_name}
   
3. Extract PR number:
   pr_number = parse_pr_number(pr_result)
   
Progress: "Pull request created (70%)"
```

**STEP 6: Update Task Master**
```
1. Update task status:
   update_task_in_taskmaster({
       id: task_id,
       status: "completed",
       pr_number: pr_number,
       implementation_time: calculate_duration()
   })
   
2. Add implementation notes:
   add_task_notes({
       metrics: review_results,
       pr_url: pr_result.url
   })
   
Progress: "Task Master updated (85%)"
```

**STEP 7: Resource Cleanup**
```
1. Determine cleanup safety:
   cleanup_decision = check_cleanup_safety(task_id)
   
2. Execute cleanup if safe:
   IF cleanup_decision.safe_to_cleanup:
       # Clean up worktree
       execute_safe_cleanup(task_id)
       
       # Remove local branch after PR created
       git branch -d {branch_name}
   ELSE:
       # Preserve resources
       LOG: "Resources preserved: " + cleanup_decision.reason
   END
   
Progress: "Finalization complete (100%)"
```

**PR CONTENT GENERATION:**

```
FUNCTION generate_pr_title(task_spec):
    # Format: "feat(scope): description (#task-id)"
    scope = determine_scope(task_spec)
    type = determine_change_type(task_spec)
    
    RETURN "{type}({scope}): {task_spec.title} (#task-{task_id})"
END

FUNCTION generate_pr_body(context):
    RETURN """
## Summary
{generate_summary(context.task_spec)}

## Changes
{format_change_list(context.implementation_summary)}

## Testing
- Test Coverage: {context.test_results.test_coverage}%
- All tests passing âœ…

## Checklist
{format_checklist(context.checklist)}

## Task Details
- Task ID: #{context.task_spec.id}
- Requirements Coverage: {context.test_results.requirements_coverage}%
- Quality Score: {context.test_results.quality_score}/10

---
*Generated by Parallel Development Orchestration*
"""
END
```

**AUTO-MERGE HANDLING:**
```
IF config.auto_merge_enabled AND pr_checks_passing(pr_number):
    # Enable auto-merge
    gh pr merge {pr_number} --auto --squash
    
    # Monitor merge status
    monitor_auto_merge(pr_number)
END
```

**OUTPUT FORMAT:**
```
{
  status: "success|blocked|failed",
  task_id: 8,
  agent_id: "finalizer-1",
  duration_minutes: 10,
  results: {
    branch_name: "feature/task-8",
    pr_number: 42,
    pr_url: "https://github.com/org/repo/pull/42",
    pr_status: "open|merged",
    cleanup_performed: true,
    resources_preserved: []
  },
  metrics: {
    commits_created: 3,
    files_changed: 8,
    lines_added: 450,
    lines_removed: 20
  },
  next_action: "monitor_pr|none"
}
```

**ERROR HANDLING:**
```
ON push_failure:
    # Check for protected branch
    IF is_protected_branch_error():
        ATTEMPT: Create PR from fork workflow
    ELSE:
        LOG: "Push failed: " + error
        RETURN: {
            status: "failed",
            reason: "Cannot push to remote",
            recovery: "Check git permissions"
        }
    END
END

ON pr_creation_failure:
    # PR might already exist
    existing_pr = find_existing_pr(branch_name)
    IF existing_pr:
        RETURN: {
            status: "success",
            pr_number: existing_pr.number,
            note: "PR already exists"
        }
    ELSE:
        RETURN: {
            status: "failed", 
            reason: "PR creation failed: " + error
        }
    END
END
```

**PERFORMANCE GUIDELINES:**
- Target finalization time: 5-10 minutes
- Minimize git operations
- Cache PR templates
- Batch Task Master updates

**BEST PRACTICES:**
- Always create PRs (never push to main)
- Include comprehensive PR descriptions
- Clean up resources only after confirming safety
- Add task reference in PR title
- Use conventional commit format

**INTEGRATION POINTS:**
- Previous: Review Agent (approved)
- External: GitHub API (via gh CLI)
- External: Task Master API
- Next: Cleanup protocols

**MONITORING HOOKS:**
- Progress updates at key stages
- PR creation notification
- Cleanup decision logging
- Auto-merge status tracking